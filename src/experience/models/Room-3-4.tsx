"use client";

/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Converted & optimized for baked texture + animated clock workflow
*/

import { useGLTF } from "@react-three/drei";
import { useFrame } from "@react-three/fiber";
import React, { useMemo, useRef } from "react";
import { TextureLoader, Mesh } from "three";

type GLTFResult = {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  nodes: {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    [name: string]: Mesh & { position?: any; rotation?: any; scale?: any };
  };
};

const Room3_4_Baked: React.FC<React.ComponentProps<"group">> = (props) => {
  const { nodes } = useGLTF("/models/Room-3-4.glb") as unknown as GLTFResult;

  // üß± Baked texture
  const bakedTexture = useMemo(() => {
    const tex = new TextureLoader().load("/textures/Room3-4.jpg");
    tex.flipY = false;
    return tex;
  }, []);

  // üïí Clock hands refs
  const hoursRef = useRef<Mesh>(null);
  const minutesRef = useRef<Mesh>(null);
  const secondsRef = useRef<Mesh>(null);

  // ‚òï Coffee smoke ref
  const smokeRef = useRef<Mesh>(null);

  // üåÄ Animate clock hands
  useFrame(() => {
    const now = new Date();
    const hours = now.getHours() % 12;
    const minutes = now.getMinutes();
    const seconds = now.getSeconds() + now.getMilliseconds() / 1000;

    // Hour hand (30¬∞ per hour)
    if (hoursRef.current)
      hoursRef.current.rotation.x = -((hours + minutes / 60) * (Math.PI / 6));

    // Minute hand (6¬∞ per minute)
    if (minutesRef.current)
      minutesRef.current.rotation.x = -(
        (minutes + seconds / 60) * (Math.PI / 30)
      );

    // Second hand (6¬∞ per second)
    if (secondsRef.current)
      secondsRef.current.rotation.x = -(seconds * (Math.PI / 30));

    // ‚òÅÔ∏è Optional smoke animation
    if (smokeRef.current) {
      smokeRef.current.rotation.y += 0.002;
      smokeRef.current.position.y += Math.sin(now.getTime() * 0.002) * 0.0003;
    }
  });

  // üñº Plane list (Plane001 ‚Üí Plane051)
  const planes = Array.from(
    { length: 51 },
    (_, i) => `Plane${String(i + 1).padStart(3, "0")}`
  );

  // üñº Photo list
  const photos = [
    "photo-1",
    "photo-2",
    "photo-3",
    "photo-4",
    "photo-5",
    "photo-6",
    "photo-7",
    "photo-8",
  ];

  return (
    <group {...props} dispose={null}>
      {/* ‚òï Coffee Smoke (optional) */}
      {nodes["coffee-smoke"] && (
        <mesh
          name="coffee-smoke"
          ref={smokeRef}
          geometry={nodes["coffee-smoke"].geometry}
          position={[-0.197, 1.298, 1.782]}
        >
          <meshBasicMaterial
            map={bakedTexture}
            transparent
            opacity={0.6}
            depthWrite={false}
          />
        </mesh>
      )}

      {/* üï∞ Clock */}
      <mesh
        geometry={nodes.Clock.geometry}
        position={[-3.626, 3.11, -1.226]}
        rotation={[0, -0.779, 0]}
      >
        <meshBasicMaterial map={bakedTexture} />
        <mesh ref={hoursRef} geometry={nodes.hours.geometry}>
          <meshBasicMaterial map={bakedTexture} />
        </mesh>
        <mesh ref={minutesRef} geometry={nodes.minutes.geometry}>
          <meshBasicMaterial map={bakedTexture} />
        </mesh>
        <mesh ref={secondsRef} geometry={nodes.secondes.geometry}>
          <meshBasicMaterial map={bakedTexture} />
        </mesh>
      </mesh>

      {/* üñº Planes (Wall Frames, Posters, etc.) */}
      {planes.map((name) => {
        const node = nodes[name];
        if (!node) return null;
        return (
          <mesh
            key={name}
            geometry={node.geometry}
            position={node.position}
            rotation={node.rotation}
            scale={node.scale}
          >
            <meshBasicMaterial map={bakedTexture} />
          </mesh>
        );
      })}

      {/* üì∏ Photos */}
      {photos.map((name) => {
        const node = nodes[name];
        if (!node) return null;
        return (
          <mesh
            key={name}
            geometry={node.geometry}
            position={node.position}
            rotation={node.rotation}
          >
            <meshBasicMaterial map={bakedTexture} />
          </mesh>
        );
      })}

      {/* üê± Schr√∂dinger Mug */}
      {nodes.schrodinger && (
        <mesh
          geometry={nodes.schrodinger.geometry}
          position={[-0.264, 1.246, 2.792]}
          rotation={[0, -1.404, 0]}
        >
          <meshBasicMaterial map={bakedTexture} />
        </mesh>
      )}
    </group>
  );
};

useGLTF.preload("/models/Room-3-4.glb");

export default Room3_4_Baked;
